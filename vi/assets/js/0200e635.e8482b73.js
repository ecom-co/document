"use strict";(self.webpackChunktemplate_docs=self.webpackChunktemplate_docs||[]).push([[7668],{10331:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ecom-co/libs/redis/docs/redis-examples","title":"Redis Module Examples & Best Practices","description":"C\xe1c v\xed d\u1ee5 th\u1ef1c t\u1ebf v\xe0 best practices khi s\u1eed d\u1ee5ng Redis module trong \u1ee9ng d\u1ee5ng NestJS.","source":"@site/docs/ecom-co/libs/redis/docs/redis-examples.md","sourceDirName":"ecom-co/libs/redis/docs","slug":"/redis-examples","permalink":"/document/vi/docs/redis-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/ecom-co/document/tree/main/docs/ecom-co/libs/redis/docs/redis-examples.md","tags":[{"inline":true,"label":"examples","permalink":"/document/vi/docs/tags/examples"},{"inline":true,"label":"best-practices","permalink":"/document/vi/docs/tags/best-practices"},{"inline":true,"label":"use-cases","permalink":"/document/vi/docs/tags/use-cases"},{"inline":true,"label":"patterns","permalink":"/document/vi/docs/tags/patterns"},{"inline":true,"label":"redis-module","permalink":"/document/vi/docs/tags/redis-module"}],"version":"current","frontMatter":{"id":"redis-examples","title":"Redis Module Examples & Best Practices","sidebar_label":"Examples & Best Practices","slug":"/redis-examples","description":"C\xe1c v\xed d\u1ee5 th\u1ef1c t\u1ebf v\xe0 best practices khi s\u1eed d\u1ee5ng Redis module trong \u1ee9ng d\u1ee5ng NestJS.","tags":["examples","best-practices","use-cases","patterns","redis-module"]},"sidebar":"tutorialSidebar","previous":{"title":"Installation & Development","permalink":"/document/vi/docs/redis-installation"},"next":{"title":"RedisFacade","permalink":"/document/vi/docs/redis-facade"}}');var s=t(74848),i=t(28453);t(11470),t(19365);const a={id:"redis-examples",title:"Redis Module Examples & Best Practices",sidebar_label:"Examples & Best Practices",slug:"/redis-examples",description:"C\xe1c v\xed d\u1ee5 th\u1ef1c t\u1ebf v\xe0 best practices khi s\u1eed d\u1ee5ng Redis module trong \u1ee9ng d\u1ee5ng NestJS.",tags:["examples","best-practices","use-cases","patterns","redis-module"]},o=void 0,c={},l=[{value:"Use Cases &amp; Examples",id:"use-cases--examples",level:2},{value:"1. User Session Management",id:"1-user-session-management",level:3},{value:"2. Product Catalog Caching",id:"2-product-catalog-caching",level:3},{value:"3. Rate Limiting Implementation",id:"3-rate-limiting-implementation",level:3},{value:"4. Distributed Lock for Order Processing",id:"4-distributed-lock-for-order-processing",level:3},{value:"5. Real-time Notifications with Pub/Sub",id:"5-real-time-notifications-with-pubsub",level:3},{value:"6. Cache Warming &amp; Background Jobs",id:"6-cache-warming--background-jobs",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Key Naming Convention",id:"1-key-naming-convention",level:3},{value:"2. Error Handling Strategy",id:"2-error-handling-strategy",level:3},{value:"3. Circuit Breaker Configuration",id:"3-circuit-breaker-configuration",level:3},{value:"4. Monitoring &amp; Alerting",id:"4-monitoring--alerting",level:3},{value:"5. Performance Optimization",id:"5-performance-optimization",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"1. Cache-Aside with Background Refresh",id:"1-cache-aside-with-background-refresh",level:3},{value:"2. Write-Through with Fallback",id:"2-write-through-with-fallback",level:3},{value:"3. Distributed Lock with Auto-Release",id:"3-distributed-lock-with-auto-release",level:3}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"T\xe0i li\u1ec7u n\xe0y cung c\u1ea5p c\xe1c v\xed d\u1ee5 th\u1ef1c t\u1ebf v\xe0 best practices khi s\u1eed d\u1ee5ng Redis module. C\xe1c v\xed d\u1ee5 \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf \u0111\u1ec3 gi\u1ea3i quy\u1ebft c\xe1c v\u1ea5n \u0111\u1ec1 th\u01b0\u1eddng g\u1eb7p trong \u1ee9ng d\u1ee5ng production."})}),"\n",(0,s.jsx)(n.h2,{id:"use-cases--examples",children:"Use Cases & Examples"}),"\n",(0,s.jsx)(n.h3,{id:"1-user-session-management",children:"1. User Session Management"}),"\n",(0,s.jsx)(n.p,{children:"Qu\u1ea3n l\xfd user sessions v\u1edbi Redis, bao g\u1ed3m caching v\xe0 TTL management."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\n\n@Injectable()\nexport class SessionService {\n    constructor(@InjectRedisFacade('session') private readonly session: RedisFacade) {}\n\n    async createSession(userId: string, sessionData: any) {\n        const sessionId = this.generateSessionId();\n        const key = `session:${sessionId}`;\n\n        await this.session.setJson(\n            key,\n            {\n                userId,\n                data: sessionData,\n                createdAt: Date.now(),\n            },\n            { ttlSeconds: 86400 },\n        ); // 24 gi\u1edd\n\n        return sessionId;\n    }\n\n    async getSession(sessionId: string) {\n        const key = `session:${sessionId}`;\n        return await this.session.getJson(key);\n    }\n\n    async updateSession(sessionId: string, updates: any) {\n        const key = `session:${sessionId}`;\n        const current = await this.getSession(sessionId);\n\n        if (!current) return null;\n\n        const updated = { ...current, ...updates, updatedAt: Date.now() };\n        await this.session.setJson(key, updated, { ttlSeconds: 86400 });\n\n        return updated;\n    }\n\n    async deleteSession(sessionId: string) {\n        const key = `session:${sessionId}`;\n        return await this.session.del(key);\n    }\n\n    async extendSession(sessionId: string, additionalSeconds: number) {\n        const key = `session:${sessionId}`;\n        const current = await this.getSession(sessionId);\n\n        if (!current) return false;\n\n        const currentTtl = await this.session.ttl(key);\n        const newTtl = currentTtl + additionalSeconds;\n\n        return await this.session.expire(key, newTtl);\n    }\n\n    private generateSessionId(): string {\n        return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-product-catalog-caching",children:"2. Product Catalog Caching"}),"\n",(0,s.jsx)(n.p,{children:"Cache product catalog v\u1edbi cache-aside pattern v\xe0 background refresh."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\n\n@Injectable()\nexport class ProductService {\n    constructor(\n        @InjectRedisFacade('catalog') private readonly cache: RedisFacade,\n        private readonly productRepository: ProductRepository,\n    ) {}\n\n    async getProduct(id: string) {\n        return await this.cache.cacheAside(\n            `product:${id}`,\n            async () => {\n                return await this.productRepository.findById(id);\n            },\n            {\n                ttlSeconds: 3600, // 1 gi\u1edd\n                refreshThreshold: 0.8, // Refresh khi 80% TTL \u0111\xe3 qua\n            },\n        );\n    }\n\n    async getProductsByCategory(categoryId: string, page: number, limit: number) {\n        const key = `products:category:${categoryId}:page:${page}:limit:${limit}`;\n\n        return await this.cache.getOrSet(key, 1800, async () => {\n            return await this.productRepository.findByCategory(categoryId, page, limit);\n        });\n    }\n\n    async searchProducts(query: string, filters: any) {\n        const cacheKey = `search:${this.hashQuery(query, filters)}`;\n\n        return await this.cache.getOrSet(cacheKey, 900, async () => {\n            return await this.productRepository.search(query, filters);\n        });\n    }\n\n    async invalidateProductCache(productId: string) {\n        // X\xf3a product cache\n        await this.cache.del(`product:${productId}`);\n\n        // X\xf3a category caches\n        const categoryKeys = await this.cache.keys('products:category:*');\n        await this.cache.del(...categoryKeys);\n\n        // X\xf3a search caches\n        const searchKeys = await this.cache.keys('search:*');\n        await this.cache.del(...searchKeys);\n    }\n\n    private hashQuery(query: string, filters: any): string {\n        return Buffer.from(JSON.stringify({ query, filters })).toString('base64');\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-rate-limiting-implementation",children:"3. Rate Limiting Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Implement rate limiting cho API endpoints v\u1edbi multiple strategies."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable, HttpException, HttpStatus } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\n\n@Injectable()\nexport class RateLimitService {\n    constructor(@InjectRedisFacade('rate-limit') private readonly cache: RedisFacade) {}\n\n    async checkUserRateLimit(userId: string, endpoint: string) {\n        const key = `rate:user:${userId}:${endpoint}`;\n        const limit = this.getEndpointLimit(endpoint);\n\n        const result = await this.cache.rateLimit(key, limit.requests, limit.window);\n\n        if (!result.allowed) {\n            throw new HttpException(\n                {\n                    message: 'Rate limit exceeded',\n                    retryAfter: result.retryAfter,\n                    resetTime: result.resetTime,\n                },\n                HttpStatus.TOO_MANY_REQUESTS,\n            );\n        }\n\n        return result;\n    }\n\n    async checkIPRateLimit(ip: string, endpoint: string) {\n        const key = `rate:ip:${ip}:${endpoint}`;\n        const limit = this.getEndpointLimit(endpoint);\n\n        const result = await this.cache.slidingWindowRateLimit(key, limit.requests, limit.window);\n\n        if (!result.allowed) {\n            throw new HttpException(\n                {\n                    message: 'IP rate limit exceeded',\n                    retryAfter: result.retryAfter,\n                },\n                HttpStatus.TOO_MANY_REQUESTS,\n            );\n        }\n\n        return result;\n    }\n\n    async checkMultipleLimits(userId: string, ip: string, endpoint: string) {\n        const limits = [\n            { key: `user:${userId}:${endpoint}`, limit: 100, windowMs: 60000 },\n            { key: `ip:${ip}:${endpoint}`, limit: 1000, windowMs: 60000 },\n        ];\n\n        const results = await this.cache.rateLimitMultiple(limits);\n\n        // Ki\u1ec3m tra t\u1ea5t c\u1ea3 limits\n        const exceeded = results.find((r) => !r.allowed);\n        if (exceeded) {\n            throw new HttpException(\n                {\n                    message: 'Rate limit exceeded',\n                    retryAfter: exceeded.retryAfter,\n                },\n                HttpStatus.TOO_MANY_REQUESTS,\n            );\n        }\n\n        return results;\n    }\n\n    private getEndpointLimit(endpoint: string) {\n        const limits = {\n            'auth:login': { requests: 5, window: 300000 }, // 5 requests / 5 ph\xfat\n            'auth:register': { requests: 3, window: 3600000 }, // 3 requests / 1 gi\u1edd\n            'api:products': { requests: 100, window: 60000 }, // 100 requests / 1 ph\xfat\n            'api:orders': { requests: 50, window: 60000 }, // 50 requests / 1 ph\xfat\n        };\n\n        return limits[endpoint] || { requests: 100, window: 60000 };\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-distributed-lock-for-order-processing",children:"4. Distributed Lock for Order Processing"}),"\n",(0,s.jsx)(n.p,{children:"S\u1eed d\u1ee5ng distributed lock \u0111\u1ec3 \u0111\u1ea3m b\u1ea3o order processing kh\xf4ng b\u1ecb duplicate."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable, ConflictException } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\n\n@Injectable()\nexport class OrderService {\n    constructor(\n        @InjectRedisFacade('orders') private readonly cache: RedisFacade,\n        private readonly orderRepository: OrderRepository,\n        private readonly inventoryService: InventoryService,\n    ) {}\n\n    async processOrder(orderId: string, orderData: any) {\n        return await this.cache.withLock(\n            `order:processing:${orderId}`,\n            30000, // 30 gi\xe2y\n            async () => {\n                // Ki\u1ec3m tra order \u0111\xe3 t\u1ed3n t\u1ea1i\n                const existing = await this.orderRepository.findById(orderId);\n                if (existing) {\n                    throw new ConflictException('Order already exists');\n                }\n\n                // Ki\u1ec3m tra inventory\n                const inventoryCheck = await this.inventoryService.checkAvailability(orderData.items);\n\n                if (!inventoryCheck.available) {\n                    throw new ConflictException('Insufficient inventory');\n                }\n\n                // T\u1ea1o order\n                const order = await this.orderRepository.create(orderData);\n\n                // C\u1eadp nh\u1eadt inventory\n                await this.inventoryService.reserveItems(orderData.items);\n\n                // Cache order\n                await this.cache.setJson(`order:${orderId}`, order, {\n                    ttlSeconds: 86400,\n                });\n\n                return order;\n            },\n            { maxRetries: 3, retryDelayMs: 100 },\n        );\n    }\n\n    async cancelOrder(orderId: string, reason: string) {\n        return await this.cache.withLock(\n            `order:cancellation:${orderId}`,\n            15000, // 15 gi\xe2y\n            async () => {\n                const order = await this.orderRepository.findById(orderId);\n\n                if (!order) {\n                    throw new ConflictException('Order not found');\n                }\n\n                if (order.status === 'CANCELLED') {\n                    throw new ConflictException('Order already cancelled');\n                }\n\n                // Cancel order\n                const cancelledOrder = await this.orderRepository.cancel(orderId, reason);\n\n                // Release inventory\n                await this.inventoryService.releaseItems(order.items);\n\n                // Update cache\n                await this.cache.setJson(`order:${orderId}`, cancelledOrder, {\n                    ttlSeconds: 86400,\n                });\n\n                return cancelledOrder;\n            },\n        );\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-real-time-notifications-with-pubsub",children:"5. Real-time Notifications with Pub/Sub"}),"\n",(0,s.jsx)(n.p,{children:"Implement real-time notifications s\u1eed d\u1ee5ng Redis pub/sub."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable, OnModuleInit } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\nimport { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';\nimport { Server } from 'socket.io';\n\n@Injectable()\n@WebSocketGateway()\nexport class NotificationService implements OnModuleInit {\n    @WebSocketServer()\n    private server: Server;\n\n    private subscriber: RedisFacade;\n\n    constructor(\n        @InjectRedisFacade('notifications') private readonly publisher: RedisFacade,\n        @InjectRedisFacade('notifications') private readonly cache: RedisFacade,\n    ) {}\n\n    async onModuleInit() {\n        // T\u1ea1o subscriber connection\n        this.subscriber = new RedisFacade(\n            this.cache['client'], // Access underlying client\n            'notifications:',\n        );\n\n        // Subscribe to channels\n        await this.subscribeToChannels();\n    }\n\n    async sendNotification(userId: string, notification: any) {\n        const channel = `user:${userId}:notifications`;\n\n        // Publish notification\n        await this.publisher.publishJson(channel, {\n            ...notification,\n            timestamp: Date.now(),\n        });\n\n        // Store in cache for offline users\n        await this.cache.lpush(`notifications:${userId}`, notification);\n\n        // Limit stored notifications\n        await this.cache.ltrim(`notifications:${userId}`, 0, 99);\n    }\n\n    async sendBroadcastNotification(notification: any, userFilter?: string[]) {\n        const channel = 'broadcast:notifications';\n\n        if (userFilter) {\n            // Send to specific users\n            for (const userId of userFilter) {\n                await this.sendNotification(userId, notification);\n            }\n        } else {\n            // Send to all users\n            await this.publisher.publishJson(channel, {\n                ...notification,\n                timestamp: Date.now(),\n            });\n        }\n    }\n\n    async getOfflineNotifications(userId: string) {\n        const key = `notifications:${userId}`;\n        const notifications = await this.cache.lrange(key, 0, -1);\n\n        // Clear after reading\n        await this.cache.del(key);\n\n        return notifications;\n    }\n\n    private async subscribeToChannels() {\n        // Subscribe to user notifications\n        const userPattern = 'user:*:notifications';\n        const userKeys = await this.cache.scanKeys(userPattern);\n\n        for (const key of userKeys) {\n            const userId = key.split(':')[1];\n            await this.subscribeToUserChannel(userId);\n        }\n\n        // Subscribe to broadcast channel\n        await this.subscribeToBroadcastChannel();\n    }\n\n    private async subscribeToUserChannel(userId: string) {\n        const channel = `user:${userId}:notifications`;\n\n        // This is a simplified example - in real implementation you'd use Redis SUBSCRIBE\n        // For now, we'll use polling approach\n        setInterval(async () => {\n            const notification = await this.cache.rpop(channel);\n            if (notification) {\n                this.server.to(`user:${userId}`).emit('notification', notification);\n            }\n        }, 1000);\n    }\n\n    private async subscribeToBroadcastChannel() {\n        const channel = 'broadcast:notifications';\n\n        // Polling approach for broadcast notifications\n        setInterval(async () => {\n            const notification = await this.cache.rpop(channel);\n            if (notification) {\n                this.server.emit('broadcast', notification);\n            }\n        }, 1000);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"6-cache-warming--background-jobs",children:"6. Cache Warming & Background Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Implement cache warming v\xe0 background jobs \u0111\u1ec3 t\u1ed1i \u01b0u performance."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable, OnModuleInit } from '@nestjs/common';\nimport { InjectRedisFacade } from '@ecom-co/redis';\nimport { RedisFacade } from '@ecom-co/redis';\nimport { Cron, CronExpression } from '@nestjs/schedule';\n\n@Injectable()\nexport class CacheWarmingService implements OnModuleInit {\n    constructor(\n        @InjectRedisFacade('cache') private readonly cache: RedisFacade,\n        private readonly productService: ProductService,\n        private readonly categoryService: CategoryService,\n    ) {}\n\n    async onModuleInit() {\n        // Warm cache on startup\n        await this.warmCache();\n    }\n\n    @Cron(CronExpression.EVERY_HOUR)\n    async warmCache() {\n        console.log('Starting cache warming...');\n\n        try {\n            // Warm popular products\n            await this.warmPopularProducts();\n\n            // Warm categories\n            await this.warmCategories();\n\n            // Warm search suggestions\n            await this.warmSearchSuggestions();\n\n            console.log('Cache warming completed');\n        } catch (error) {\n            console.error('Cache warming failed:', error);\n        }\n    }\n\n    private async warmPopularProducts() {\n        const popularProducts = await this.productService.getPopularProducts();\n\n        for (const product of popularProducts) {\n            await this.cache.setJson(`product:${product.id}`, product, { ttlSeconds: 3600 });\n        }\n    }\n\n    private async warmCategories() {\n        const categories = await this.categoryService.getAllCategories();\n\n        for (const category of categories) {\n            await this.cache.setJson(`category:${category.id}`, category, { ttlSeconds: 7200 });\n\n            // Warm first page of products for each category\n            const products = await this.productService.getProductsByCategory(category.id, 1, 20);\n\n            await this.cache.setJson(`products:category:${category.id}:page:1:limit:20`, products, {\n                ttlSeconds: 1800,\n            });\n        }\n    }\n\n    private async warmSearchSuggestions() {\n        const suggestions = await this.productService.getSearchSuggestions();\n\n        await this.cache.setJson('search:suggestions', suggestions, { ttlSeconds: 3600 });\n    }\n\n    @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)\n    async cleanupExpiredCache() {\n        console.log('Starting cache cleanup...');\n\n        try {\n            // Find expired keys\n            const expiredKeys = await this.cache.scanKeys('*');\n            const toDelete: string[] = [];\n\n            for (const key of expiredKeys) {\n                const ttl = await this.cache.ttl(key);\n                if (ttl === -2) {\n                    // Key doesn't exist\n                    toDelete.push(key);\n                }\n            }\n\n            if (toDelete.length > 0) {\n                // Delete in batches\n                const batches = this.chunkArray(toDelete, 1000);\n\n                for (const batch of batches) {\n                    await this.cache.del(...batch);\n                }\n\n                console.log(`Cleaned up ${toDelete.length} expired keys`);\n            }\n        } catch (error) {\n            console.error('Cache cleanup failed:', error);\n        }\n    }\n\n    private chunkArray<T>(array: T[], size: number): T[][] {\n        const chunks: T[][] = [];\n\n        for (let i = 0; i < array.length; i += size) {\n            chunks.push(array.slice(i, i + size));\n        }\n\n        return chunks;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-key-naming-convention",children:"1. Key Naming Convention"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2705 T\u1ed1t - S\u1eed d\u1ee5ng colon separator v\xe0 descriptive names\nconst keys = {\n    user: `user:${userId}:profile`,\n    session: `session:${sessionId}`,\n    product: `product:${productId}:details`,\n    category: `category:${categoryId}:products:page:${page}:limit:${limit}`,\n    search: `search:${hashQuery(query, filters)}`,\n    rateLimit: `rate:user:${userId}:${endpoint}`,\n    lock: `lock:order:${orderId}:processing`,\n};\n\n// \u274c Kh\xf4ng t\u1ed1t - Kh\xf4ng c\xf3 structure\nconst badKeys = {\n    user: `u_${userId}`,\n    session: `s_${sessionId}`,\n    product: `p_${productId}`,\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-error-handling-strategy",children:"2. Error Handling Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class RobustCacheService {\n    constructor(\n        @InjectRedisFacade() private readonly cache: RedisFacade,\n        private readonly logger: Logger,\n    ) {}\n\n    async getWithFallback<T>(key: string, fallback: () => Promise<T>): Promise<T> {\n        try {\n            const cached = await this.cache.get<T>(key);\n            if (cached !== null) {\n                return cached;\n            }\n        } catch (error) {\n            this.logger.warn(`Cache get failed for key ${key}:`, error);\n        }\n\n        try {\n            const fresh = await fallback();\n\n            // Try to cache, but don't fail if it doesn't work\n            try {\n                await this.cache.set(key, fresh, { ttlSeconds: 3600 });\n            } catch (cacheError) {\n                this.logger.warn(`Cache set failed for key ${key}:`, cacheError);\n            }\n\n            return fresh;\n        } catch (fallbackError) {\n            this.logger.error(`Fallback failed for key ${key}:`, fallbackError);\n            throw fallbackError;\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-circuit-breaker-configuration",children:"3. Circuit Breaker Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const productionConfig = {\n    circuitBreakerThreshold: 10, // Higher threshold for production\n    circuitBreakerTimeout: 120000, // 2 minutes timeout\n    maxRetries: 5, // More retries\n    retryDelay: 200, // Longer delay\n    bulkOperationChunkSize: 500, // Smaller chunks for stability\n    statsFlushInterval: 10000, // More frequent stats\n};\n\nconst developmentConfig = {\n    circuitBreakerThreshold: 3, // Lower threshold for development\n    circuitBreakerTimeout: 30000, // 30 seconds timeout\n    maxRetries: 2, // Fewer retries\n    retryDelay: 100, // Shorter delay\n    bulkOperationChunkSize: 1000, // Larger chunks for speed\n    statsFlushInterval: 5000, // Less frequent stats\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-monitoring--alerting",children:"4. Monitoring & Alerting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class CacheMonitoringService {\n    constructor(\n        @InjectRedisFacade() private readonly cache: RedisFacade,\n        private readonly alertService: AlertService,\n    ) {}\n\n    @Cron(CronExpression.EVERY_MINUTE)\n    async monitorCacheHealth() {\n        try {\n            const health = await this.cache.healthCheck();\n\n            if (health.status === 'unhealthy') {\n                await this.alertService.sendAlert({\n                    level: 'ERROR',\n                    message: `Redis cache is unhealthy: ${health.error}`,\n                    context: { latency: health.latency },\n                });\n            }\n\n            if (health.latency > 100) {\n                // > 100ms\n                await this.alertService.sendAlert({\n                    level: 'WARNING',\n                    message: `Redis cache latency is high: ${health.latency}ms`,\n                    context: { latency: health.latency },\n                });\n            }\n        } catch (error) {\n            await this.alertService.sendAlert({\n                level: 'ERROR',\n                message: 'Cache monitoring failed',\n                context: { error: error.message },\n            });\n        }\n    }\n\n    @Cron(CronExpression.EVERY_5_MINUTES)\n    async monitorCacheStats() {\n        try {\n            const stats = await this.cache.getCacheStats();\n\n            // Alert if hit rate is too low\n            if (stats.hitRate < 80) {\n                await this.alertService.sendAlert({\n                    level: 'WARNING',\n                    message: `Cache hit rate is low: ${stats.hitRate}%`,\n                    context: { hitRate: stats.hitRate, totalRequests: stats.totalRequests },\n                });\n            }\n\n            // Alert if memory usage is high\n            if (stats.memoryUsage.includes('GB') && parseFloat(stats.memoryUsage) > 1) {\n                await this.alertService.sendAlert({\n                    level: 'WARNING',\n                    message: `Cache memory usage is high: ${stats.memoryUsage}`,\n                    context: { memoryUsage: stats.memoryUsage },\n                });\n            }\n        } catch (error) {\n            this.logger.error('Cache stats monitoring failed:', error);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-performance-optimization",children:"5. Performance Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class OptimizedCacheService {\n    constructor(@InjectRedisFacade() private readonly cache: RedisFacade) {}\n\n    async getMultipleProducts(productIds: string[]) {\n        // S\u1eed d\u1ee5ng mget thay v\xec multiple get calls\n        const keys = productIds.map((id) => `product:${id}`);\n        const products = await this.cache.mget(keys);\n\n        // Filter out null values and map back to original structure\n        return products\n            .map((product, index) => (product ? { id: productIds[index], ...product } : null))\n            .filter(Boolean);\n    }\n\n    async setMultipleProducts(products: Array<{ id: string; data: any }>) {\n        // S\u1eed d\u1ee5ng mset v\u1edbi options\n        const operations = products.map(({ id, data }) => ({\n            key: `product:${id}`,\n            value: data,\n            options: { ttlSeconds: 3600 },\n        }));\n\n        await this.cache.mset(operations);\n    }\n\n    async invalidateRelatedCache(productId: string) {\n        // S\u1eed d\u1ee5ng pipeline \u0111\u1ec3 invalidate multiple keys\n        const pipeline = this.cache.pipeline();\n\n        // Find related keys\n        const relatedKeys = await this.cache.scanKeys(`*${productId}*`);\n\n        // Add delete operations to pipeline\n        relatedKeys.forEach((key) => pipeline.del(key));\n\n        // Execute all deletions at once\n        await pipeline.exec();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"1-cache-aside-with-background-refresh",children:"1. Cache-Aside with Background Refresh"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async getDataWithBackgroundRefresh<T>(key: string, loader: () => Promise<T>): Promise<T> {\n  const cached = await this.cache.get<T>(key);\n\n  if (cached) {\n    // Background refresh if near expiry\n    this.backgroundRefresh(key, loader).catch(console.error);\n    return cached;\n  }\n\n  const fresh = await loader();\n  await this.cache.set(key, fresh, { ttlSeconds: 3600 });\n\n  return fresh;\n}\n\nprivate async backgroundRefresh<T>(key: string, loader: () => Promise<T>) {\n  try {\n    const fresh = await loader();\n    await this.cache.set(key, fresh, { ttlSeconds: 3600 });\n  } catch (error) {\n    // Log error but don't fail the main operation\n    console.error('Background refresh failed:', error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-write-through-with-fallback",children:"2. Write-Through with Fallback"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async writeThroughWithFallback<T>(\n  key: string,\n  value: T,\n  writer: (value: T) => Promise<void>,\n  options?: RedisSetOptions\n): Promise<void> {\n  try {\n    // Try to write to both cache and database\n    await Promise.all([\n      this.cache.setJson(key, value, options),\n      writer(value)\n    ]);\n  } catch (error) {\n    // If database write fails, still cache the data\n    try {\n      await this.cache.setJson(key, value, options);\n    } catch (cacheError) {\n      console.error('Cache write failed:', cacheError);\n    }\n\n    // Re-throw the original error\n    throw error;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-distributed-lock-with-auto-release",children:"3. Distributed Lock with Auto-Release"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async withAutoReleaseLock<T>(\n  key: string,\n  ttlMs: number,\n  operation: () => Promise<T>\n): Promise<T> {\n  const lock = await this.cache.acquireLock(key, ttlMs);\n\n  if (!lock.ok) {\n    throw new Error(`Failed to acquire lock for key: ${key}`);\n  }\n\n  // Auto-release lock after TTL\n  const autoRelease = setTimeout(async () => {\n    try {\n      await lock.release?.();\n    } catch (error) {\n      console.error('Auto-release lock failed:', error);\n    }\n  }, ttlMs);\n\n  try {\n    const result = await operation();\n\n    // Clear auto-release and manually release\n    clearTimeout(autoRelease);\n    await lock.release?.();\n\n    return result;\n  } catch (error) {\n    // Clear auto-release and manually release on error\n    clearTimeout(autoRelease);\n    await lock.release?.();\n    throw error;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Tip"}),": Lu\xf4n s\u1eed d\u1ee5ng batch operations v\xe0 pipeline khi c\xf3 th\u1ec3 \u0111\u1ec3 gi\u1ea3m network round trips."]})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security Warning"}),": Kh\xf4ng bao gi\u1edd cache sensitive data nh\u01b0 passwords, tokens, ho\u1eb7c PII m\xe0 kh\xf4ng c\xf3 encryption."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Monitoring Tip"}),": Implement comprehensive monitoring cho Redis operations \u0111\u1ec3 detect performance issues s\u1edbm."]})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11470:(e,n,t)=>{t.d(n,{A:()=>x});var r=t(96540),s=t(34164),i=t(23104),a=t(56347),o=t(205),c=t(57485),l=t(31682),d=t(70679);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:r}})=>({value:e,label:n,attributes:t,default:r}))}(t);return function(e){const n=(0,l.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const t=(0,a.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(s),(0,r.useCallback)(e=>{if(!s)return;const n=new URLSearchParams(t.location.search);n.set(s,e),t.replace({...t.location,search:n.toString()})},[s,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,i=h(e),[a,c]=(0,r.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i})),[l,u]=m({queryString:t,groupId:s}),[g,y]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,d.Dv)(n);return[t,(0,r.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),f=(()=>{const e=l??g;return p({value:e,tabValues:i})?e:null})();(0,o.A)(()=>{f&&c(f)},[f]);return{selectedValue:a,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),y(e)},[u,y,i]),tabValues:i}}var y=t(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(74848);function b({className:e,block:n,selectedValue:t,selectValue:r,tabValues:a}){const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),l=e=>{const n=e.currentTarget,s=o.indexOf(n),i=a[s].value;i!==t&&(c(n),r(i))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:r})=>(0,v.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:l,...r,className:(0,s.A)("tabs__item",f.tabItem,r?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function w({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function k(e){const n=g(e);return(0,v.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,v.jsx)(b,{...n,...e}),(0,v.jsx)(w,{...n,...e})]})}function x(e){const n=(0,y.A)();return(0,v.jsx)(k,{...e,children:u(e.children)},String(n))}},19365:(e,n,t)=>{t.d(n,{A:()=>a});t(96540);var r=t(34164);const s={tabItem:"tabItem_Ymn6"};var i=t(74848);function a({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,t),hidden:n,children:e})}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);