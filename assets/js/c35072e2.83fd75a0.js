"use strict";(self.webpackChunktemplate_docs=self.webpackChunktemplate_docs||[]).push([[4544],{6677:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"overview/services","title":"Services","description":"T\xecm hi\u1ec3u v\u1ec1 Services - ch\u1ee9a business logic v\xe0 x\u1eed l\xfd d\u1eef li\u1ec7u trong NestJS","source":"@site/docs/overview/services.md","sourceDirName":"overview","slug":"/overview/services","permalink":"/document/docs/overview/services","draft":false,"unlisted":false,"editUrl":"https://github.com/ecom-co/document/tree/main/docs/overview/services.md","tags":[],"version":"current","frontMatter":{"title":"Services","description":"T\xecm hi\u1ec3u v\u1ec1 Services - ch\u1ee9a business logic v\xe0 x\u1eed l\xfd d\u1eef li\u1ec7u trong NestJS"}}');var i=r(4848),t=r(8453);const a={title:"Services",description:"T\xecm hi\u1ec3u v\u1ec1 Services - ch\u1ee9a business logic v\xe0 x\u1eed l\xfd d\u1eef li\u1ec7u trong NestJS"},o="Services",c={},l=[{value:"Services l\xe0 g\xec?",id:"services-l\xe0-g\xec",level:2},{value:"T\u1ea1o Service c\u01a1 b\u1ea3n",id:"t\u1ea1o-service-c\u01a1-b\u1ea3n",level:2},{value:"Injectable Services",id:"injectable-services",level:2},{value:"Decorator @Injectable()",id:"decorator-injectable",level:3},{value:"Constructor Injection",id:"constructor-injection",level:3},{value:"Service Methods",id:"service-methods",level:2},{value:"CRUD Operations",id:"crud-operations",level:3},{value:"Data Validation",id:"data-validation",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Logging",id:"logging",level:3},{value:"External API Calls",id:"external-api-calls",level:2},{value:"Database Operations",id:"database-operations",level:2},{value:"Service Composition",id:"service-composition",level:2},{value:"Async/Await Pattern",id:"asyncawait-pattern",level:2},{value:"Service Lifecycle",id:"service-lifecycle",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Single Responsibility",id:"1-single-responsibility",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Validation",id:"3-validation",level:3},{value:"4. Logging",id:"4-logging",level:3},{value:"5. Testing",id:"5-testing",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"services",children:"Services"})}),"\n",(0,i.jsx)(n.p,{children:"Services l\xe0 c\xe1c providers ch\u1ee9a business logic v\xe0 x\u1eed l\xfd d\u1eef li\u1ec7u c\u1ee7a \u1ee9ng d\u1ee5ng. Ch\xfang \u0111\u01b0\u1ee3c inject v\xe0o controllers v\xe0 c\xe1c services kh\xe1c th\xf4ng qua Dependency Injection system c\u1ee7a NestJS."}),"\n",(0,i.jsx)(n.h2,{id:"services-l\xe0-g\xec",children:"Services l\xe0 g\xec?"}),"\n",(0,i.jsx)(n.p,{children:"Services trong NestJS:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Business Logic"})," - ch\u1ee9a logic nghi\u1ec7p v\u1ee5 ch\xednh c\u1ee7a \u1ee9ng d\u1ee5ng"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data Processing"})," - x\u1eed l\xfd v\xe0 bi\u1ebfn \u0111\u1ed5i d\u1eef li\u1ec7u"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"External API Calls"})," - g\u1ecdi API b\xean ngo\xe0i"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Operations"})," - thao t\xe1c v\u1edbi c\u01a1 s\u1edf d\u1eef li\u1ec7u"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Providers"})," - \u0111\u01b0\u1ee3c qu\u1ea3n l\xfd b\u1edfi NestJS DI container"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"t\u1ea1o-service-c\u01a1-b\u1ea3n",children:"T\u1ea1o Service c\u01a1 b\u1ea3n"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UserService {\n  private readonly users = [\n    { id: 1, name: 'John', email: 'john@example.com' },\n    { id: 2, name: 'Jane', email: 'jane@example.com' },\n  ];\n\n  findAll() {\n    return this.users;\n  }\n\n  findOne(id: number) {\n    return this.users.find(user => user.id === id);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"injectable-services",children:"Injectable Services"}),"\n",(0,i.jsx)(n.h3,{id:"decorator-injectable",children:"Decorator @Injectable()"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  // Service logic here\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Vai tr\xf2:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u0110\xe1nh d\u1ea5u class l\xe0 provider c\xf3 th\u1ec3 inject"}),"\n",(0,i.jsx)(n.li,{children:"\u0110\u01b0\u1ee3c qu\u1ea3n l\xfd b\u1edfi NestJS DI container"}),"\n",(0,i.jsx)(n.li,{children:"C\xf3 th\u1ec3 inject v\xe0o controllers ho\u1eb7c services kh\xe1c"}),"\n",(0,i.jsx)(n.li,{children:"H\u1ed7 tr\u1ee3 singleton pattern m\u1eb7c \u0111\u1ecbnh"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"constructor-injection",children:"Constructor Injection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(\n    private readonly userRepository: UserRepository,\n    private readonly emailService: EmailService,\n    private readonly configService: ConfigService,\n  ) {}\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-methods",children:"Service Methods"}),"\n",(0,i.jsx)(n.h3,{id:"crud-operations",children:"CRUD Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n  ) {}\n\n  // Create\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    const user = this.userRepository.create(createUserDto);\n    return await this.userRepository.save(user);\n  }\n\n  // Read\n  async findAll(): Promise<User[]> {\n    return await this.userRepository.find();\n  }\n\n  async findOne(id: number): Promise<User> {\n    const user = await this.userRepository.findOne({ where: { id } });\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    return user;\n  }\n\n  // Update\n  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {\n    const user = await this.findOne(id);\n    Object.assign(user, updateUserDto);\n    return await this.userRepository.save(user);\n  }\n\n  // Delete\n  async remove(id: number): Promise<void> {\n    const user = await this.findOne(id);\n    await this.userRepository.remove(user);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"data-validation",children:"Data Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    // Validate email format\n    if (!this.isValidEmail(createUserDto.email)) {\n      throw new BadRequestException('Invalid email format');\n    }\n\n    // Check if email already exists\n    const existingUser = await this.userRepository.findOne({\n      where: { email: createUserDto.email }\n    });\n    \n    if (existingUser) {\n      throw new ConflictException('Email already exists');\n    }\n\n    // Validate business rules\n    await this.validateBusinessRules(createUserDto);\n\n    return await this.userRepository.save(createUserDto);\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  private async validateBusinessRules(createUserDto: CreateUserDto): Promise<void> {\n    // Business validation logic\n    if (createUserDto.age < 18) {\n      throw new BadRequestException('User must be at least 18 years old');\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async findOne(id: number): Promise<User> {\n    try {\n      const user = await this.userRepository.findOne({ where: { id } });\n      \n      if (!user) {\n        throw new NotFoundException(`User with ID ${id} not found`);\n      }\n      \n      return user;\n    } catch (error) {\n      if (error instanceof NotFoundException) {\n        throw error;\n      }\n      \n      this.logger.error(`Error finding user ${id}:`, error);\n      throw new InternalServerErrorException('Failed to fetch user');\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(private readonly logger: Logger) {}\n\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    this.logger.log(`Creating user with email: ${createUserDto.email}`);\n    \n    try {\n      const user = await this.userRepository.save(createUserDto);\n      this.logger.log(`User created successfully with ID: ${user.id}`);\n      return user;\n    } catch (error) {\n      this.logger.error(`Failed to create user: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"external-api-calls",children:"External API Calls"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  async fetchUserFromExternalAPI(userId: string): Promise<any> {\n    const apiUrl = this.configService.get('EXTERNAL_API_URL');\n    \n    try {\n      const response = await this.httpService\n        .get(`${apiUrl}/users/${userId}`)\n        .toPromise();\n      \n      return response.data;\n    } catch (error) {\n      this.logger.error(`External API error: ${error.message}`);\n      throw new ServiceUnavailableException('External API is not available');\n    }\n  }\n\n  async syncUserData(userId: string): Promise<void> {\n    const externalData = await this.fetchUserFromExternalAPI(userId);\n    await this.updateUserFromExternalData(userId, externalData);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"database-operations",children:"Database Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n  ) {}\n\n  async findUsersWithPosts(): Promise<User[]> {\n    return await this.userRepository\n      .createQueryBuilder('user')\n      .leftJoinAndSelect('user.posts', 'post')\n      .where('post.isPublished = :isPublished', { isPublished: true })\n      .orderBy('user.createdAt', 'DESC')\n      .getMany();\n  }\n\n  async findUsersByRole(role: string): Promise<User[]> {\n    return await this.userRepository.find({\n      where: { role },\n      order: { createdAt: 'DESC' },\n      relations: ['profile', 'settings'],\n    });\n  }\n\n  async updateUserStatus(id: number, status: string): Promise<User> {\n    await this.userRepository.update(id, { status });\n    return await this.findOne(id);\n  }\n\n  async findUsersByCriteria(criteria: UserSearchCriteria): Promise<User[]> {\n    const queryBuilder = this.userRepository.createQueryBuilder('user');\n\n    if (criteria.name) {\n      queryBuilder.andWhere('user.name LIKE :name', { name: `%${criteria.name}%` });\n    }\n\n    if (criteria.email) {\n      queryBuilder.andWhere('user.email LIKE :email', { email: `%${criteria.email}%` });\n    }\n\n    if (criteria.role) {\n      queryBuilder.andWhere('user.role = :role', { role: criteria.role });\n    }\n\n    return await queryBuilder.getMany();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-composition",children:"Service Composition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class OrderService {\n  constructor(\n    private readonly userService: UserService,\n    private readonly productService: ProductService,\n    private readonly emailService: EmailService,\n    private readonly paymentService: PaymentService,\n  ) {}\n\n  async createOrder(createOrderDto: CreateOrderDto): Promise<Order> {\n    // Validate user\n    const user = await this.userService.findOne(createOrderDto.userId);\n    \n    // Validate products\n    const products = await Promise.all(\n      createOrderDto.productIds.map(id => this.productService.findOne(id))\n    );\n    \n    // Calculate total\n    const total = this.calculateTotal(products);\n    \n    // Process payment\n    const payment = await this.paymentService.processPayment({\n      amount: total,\n      userId: user.id,\n      paymentMethod: createOrderDto.paymentMethod,\n    });\n    \n    // Create order\n    const order = await this.orderRepository.save({\n      user,\n      products,\n      total,\n      paymentId: payment.id,\n      status: 'pending',\n    });\n    \n    // Send confirmation email\n    await this.emailService.sendOrderConfirmation(user.email, order);\n    \n    return order;\n  }\n\n  private calculateTotal(products: Product[]): number {\n    return products.reduce((sum, product) => sum + product.price, 0);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"asyncawait-pattern",children:"Async/Await Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async findAll(): Promise<User[]> {\n    return await this.userRepository.find();\n  }\n\n  async findOne(id: number): Promise<User> {\n    const user = await this.userRepository.findOne({ where: { id } });\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    return user;\n  }\n\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    const user = this.userRepository.create(createUserDto);\n    return await this.userRepository.save(user);\n  }\n\n  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {\n    const user = await this.findOne(id);\n    Object.assign(user, updateUserDto);\n    return await this.userRepository.save(user);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-lifecycle",children:"Service Lifecycle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService implements OnModuleInit, OnModuleDestroy {\n  constructor(private readonly logger: Logger) {}\n\n  onModuleInit() {\n    this.logger.log('UserService initialized');\n  }\n\n  onModuleDestroy() {\n    this.logger.log('UserService destroyed');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-single-responsibility",children:"1. Single Responsibility"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 T\u1ed1t - M\u1ed7i service c\xf3 m\u1ed9t tr\xe1ch nhi\u1ec7m\n@Injectable()\nexport class UserService {\n  // Ch\u1ec9 x\u1eed l\xfd user-related logic\n}\n\n@Injectable()\nexport class EmailService {\n  // Ch\u1ec9 x\u1eed l\xfd email-related logic\n}\n\n@Injectable()\nexport class PaymentService {\n  // Ch\u1ec9 x\u1eed l\xfd payment-related logic\n}\n\n// \u274c Kh\xf4ng t\u1ed1t - Service l\xe0m qu\xe1 nhi\u1ec1u vi\u1ec7c\n@Injectable()\nexport class UserService {\n  // X\u1eed l\xfd user, email, payment, notification...\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async findOne(id: number): Promise<User> {\n    try {\n      const user = await this.userRepository.findOne({ where: { id } });\n      if (!user) {\n        throw new NotFoundException(`User ${id} not found`);\n      }\n      return user;\n    } catch (error) {\n      this.logger.error(`Error finding user ${id}:`, error);\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-validation",children:"3. Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    // Validate input\n    await this.validateUserData(createUserDto);\n    \n    // Check business rules\n    await this.checkBusinessRules(createUserDto);\n    \n    // Create user\n    return await this.userRepository.save(createUserDto);\n  }\n\n  private async validateUserData(createUserDto: CreateUserDto): Promise<void> {\n    // Validation logic\n  }\n\n  private async checkBusinessRules(createUserDto: CreateUserDto): Promise<void> {\n    // Business rules logic\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-logging",children:"4. Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  constructor(private readonly logger: Logger) {}\n\n  async create(createUserDto: CreateUserDto): Promise<User> {\n    this.logger.log(`Creating user: ${createUserDto.email}`);\n    \n    const user = await this.userRepository.save(createUserDto);\n    \n    this.logger.log(`User created: ${user.id}`);\n    return user;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-testing",children:"5. Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class UserService {\n  async findOne(id: number): Promise<User> {\n    const user = await this.userRepository.findOne({ where: { id } });\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    return user;\n  }\n}\n\n// Test\ndescribe('UserService', () => {\n  it('should find user by id', async () => {\n    const user = await userService.findOne(1);\n    expect(user).toBeDefined();\n    expect(user.id).toBe(1);\n  });\n\n  it('should throw NotFoundException for non-existent user', async () => {\n    await expect(userService.findOne(999)).rejects.toThrow(NotFoundException);\n  });\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.admonition,{title:"L\u1eddi khuy\xean",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Services n\xean ch\u1ee9a business logic, kh\xf4ng ph\u1ea3i HTTP logic"}),"\n",(0,i.jsx)(n.li,{children:"S\u1eed d\u1ee5ng async/await cho database operations"}),"\n",(0,i.jsx)(n.li,{children:"X\u1eed l\xfd l\u1ed7i m\u1ed9t c\xe1ch th\u1ed1ng nh\u1ea5t"}),"\n",(0,i.jsx)(n.li,{children:"Log c\xe1c ho\u1ea1t \u0111\u1ed9ng quan tr\u1ecdng"}),"\n",(0,i.jsx)(n.li,{children:"Vi\u1ebft test cho m\u1ecdi service method"}),"\n",(0,i.jsx)(n.li,{children:"S\u1eed d\u1ee5ng dependency injection \u0111\u1ec3 gi\u1ea3m coupling"}),"\n"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"B\xe0i tr\u01b0\u1edbc:"})," ",(0,i.jsx)(n.a,{href:"/docs/overview/controllers",children:"Controllers"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"B\xe0i ti\u1ebfp theo:"})," ",(0,i.jsx)(n.a,{href:"/docs/overview/providers",children:"Providers"})]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);